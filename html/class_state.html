<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Code for: The Influence of Experimental Imperfections on Photonic GHZ State Generation: State&lt; Key, Val, Real &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Code for: The Influence of Experimental Imperfections on Photonic GHZ State Generation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_state-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">State&lt; Key, Val, Real &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;Key, Val&gt;.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;State.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for State&lt; Key, Val, Real &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_state.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a559115dd63d883bd5b14b3563337eedc" id="r_a559115dd63d883bd5b14b3563337eedc"><td class="memItemLeft" align="right" valign="top"><a id="a559115dd63d883bd5b14b3563337eedc" name="a559115dd63d883bd5b14b3563337eedc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>State</b> ()</td></tr>
<tr class="memdesc:a559115dd63d883bd5b14b3563337eedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new (empty) <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> object. <br /></td></tr>
<tr class="separator:a559115dd63d883bd5b14b3563337eedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fcd8cfa1516d9682b8e99b98b0acff" id="r_a01fcd8cfa1516d9682b8e99b98b0acff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01fcd8cfa1516d9682b8e99b98b0acff">State</a> (<a class="el" href="class_key.html">Key</a> k)</td></tr>
<tr class="memdesc:a01fcd8cfa1516d9682b8e99b98b0acff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> object from a single key with amplitude 1.0.  <br /></td></tr>
<tr class="separator:a01fcd8cfa1516d9682b8e99b98b0acff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9eb3b634fa0ade70650bf58795ed92" id="r_aed9eb3b634fa0ade70650bf58795ed92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed9eb3b634fa0ade70650bf58795ed92">set</a> (Val(*f)(const WF &amp;, const WF &amp;))</td></tr>
<tr class="memdesc:aed9eb3b634fa0ade70650bf58795ed92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the overlap function to f.  <br /></td></tr>
<tr class="separator:aed9eb3b634fa0ade70650bf58795ed92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522ab1b3df807b91edf4e67dda23f604" id="r_a522ab1b3df807b91edf4e67dda23f604"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a522ab1b3df807b91edf4e67dda23f604">set</a> (Real t)</td></tr>
<tr class="memdesc:a522ab1b3df807b91edf4e67dda23f604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the tolerance to t.  <br /></td></tr>
<tr class="separator:a522ab1b3df807b91edf4e67dda23f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72801b6de32a55c5c53d379e1d6937c" id="r_aa72801b6de32a55c5c53d379e1d6937c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa72801b6de32a55c5c53d379e1d6937c">set</a> (Int n)</td></tr>
<tr class="memdesc:aa72801b6de32a55c5c53d379e1d6937c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the lossMode to n.  <br /></td></tr>
<tr class="separator:aa72801b6de32a55c5c53d379e1d6937c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d3c086d22cb5792ba4098877199190" id="r_a22d3c086d22cb5792ba4098877199190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22d3c086d22cb5792ba4098877199190">set</a> (Par &amp;&amp;p) noexcept</td></tr>
<tr class="memdesc:a22d3c086d22cb5792ba4098877199190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actual <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> data to p.  <br /></td></tr>
<tr class="separator:a22d3c086d22cb5792ba4098877199190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2188cc37ec161676437fa8a74e4d4e" id="r_a2f2188cc37ec161676437fa8a74e4d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f2188cc37ec161676437fa8a74e4d4e">set</a> (const Par &amp;p)</td></tr>
<tr class="memdesc:a2f2188cc37ec161676437fa8a74e4d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actual <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> data to p.  <br /></td></tr>
<tr class="separator:a2f2188cc37ec161676437fa8a74e4d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5234310447732ffc214861d28fbefa" id="r_abc5234310447732ffc214861d28fbefa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc5234310447732ffc214861d28fbefa">set</a> (const <a class="el" href="class_key.html">Key</a> &amp;k, const Val &amp;v)</td></tr>
<tr class="memdesc:abc5234310447732ffc214861d28fbefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts/assigns a new <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> Value pair.  <br /></td></tr>
<tr class="separator:abc5234310447732ffc214861d28fbefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d6ccad44894abc4330c4fbe9270d5f" id="r_a16d6ccad44894abc4330c4fbe9270d5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16d6ccad44894abc4330c4fbe9270d5f">set</a> (<a class="el" href="class_key.html">Key</a> &amp;&amp;k, const Val &amp;v)</td></tr>
<tr class="memdesc:a16d6ccad44894abc4330c4fbe9270d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts/assigns a new <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> Value pair.  <br /></td></tr>
<tr class="separator:a16d6ccad44894abc4330c4fbe9270d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa805363c158f4c2b87764573b6456c31" id="r_aa805363c158f4c2b87764573b6456c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa805363c158f4c2b87764573b6456c31">set</a> (Int a, Int b, Int c, const Val &amp;v)</td></tr>
<tr class="memdesc:aa805363c158f4c2b87764573b6456c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts/assigns a new <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> Value pair. The key is implicitly given by (a,b,c).  <br /></td></tr>
<tr class="separator:aa805363c158f4c2b87764573b6456c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8877a9c19ffcff50d0354cc10462ba1" id="r_ab8877a9c19ffcff50d0354cc10462ba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8877a9c19ffcff50d0354cc10462ba1">add</a> (const Par &amp;p)</td></tr>
<tr class="memdesc:ab8877a9c19ffcff50d0354cc10462ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an state-like object to a <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a>. If a <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> is already in the state the amplitudes are added.  <br /></td></tr>
<tr class="separator:ab8877a9c19ffcff50d0354cc10462ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985c54028c867aabc1ddd66637991a22" id="r_a985c54028c867aabc1ddd66637991a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a985c54028c867aabc1ddd66637991a22">add</a> (Par &amp;&amp;p)</td></tr>
<tr class="memdesc:a985c54028c867aabc1ddd66637991a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an state-like object to a <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a>. If a <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> is already in the state the amplitudes are added.  <br /></td></tr>
<tr class="separator:a985c54028c867aabc1ddd66637991a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4d7c18169dd2bdfa3c73f0b01323bb" id="r_a3a4d7c18169dd2bdfa3c73f0b01323bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a4d7c18169dd2bdfa3c73f0b01323bb">add</a> (const Par &amp;p, const Val &amp;v)</td></tr>
<tr class="memdesc:a3a4d7c18169dd2bdfa3c73f0b01323bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an scaled state-like object to a <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a>. If a <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> is already in the state the amplitudes are added.  <br /></td></tr>
<tr class="separator:a3a4d7c18169dd2bdfa3c73f0b01323bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab631f04d9ef0521c2058732fb93975d1" id="r_ab631f04d9ef0521c2058732fb93975d1"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab631f04d9ef0521c2058732fb93975d1">norm</a> () const</td></tr>
<tr class="memdesc:ab631f04d9ef0521c2058732fb93975d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the norm of a state.  <br /></td></tr>
<tr class="separator:ab631f04d9ef0521c2058732fb93975d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f03e6d6166f4c24326de519b8d302f" id="r_a21f03e6d6166f4c24326de519b8d302f"><td class="memItemLeft" align="right" valign="top">Par&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f03e6d6166f4c24326de519b8d302f">getPar</a> ()</td></tr>
<tr class="memdesc:a21f03e6d6166f4c24326de519b8d302f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Par, i.e. boost::container::flat_map&lt;Key, Val&gt;, object.  <br /></td></tr>
<tr class="separator:a21f03e6d6166f4c24326de519b8d302f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa321f0283f93309ab7eb1033edbaefba" id="r_aa321f0283f93309ab7eb1033edbaefba"><td class="memItemLeft" align="right" valign="top">Par &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa321f0283f93309ab7eb1033edbaefba">get_parMoved</a> ()</td></tr>
<tr class="memdesc:aa321f0283f93309ab7eb1033edbaefba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Par, i.e. boost::container::flat_map&lt;Key, Val&gt;, object moved.  <br /></td></tr>
<tr class="separator:aa321f0283f93309ab7eb1033edbaefba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe8474455fc717080b8f49f40fb4e02" id="r_abfe8474455fc717080b8f49f40fb4e02"><td class="memItemLeft" align="right" valign="top">OWF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfe8474455fc717080b8f49f40fb4e02">addBasisElem</a> (const WF &amp;)</td></tr>
<tr class="memdesc:abfe8474455fc717080b8f49f40fb4e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses Gram-Schmidt procedure to add a basis element to the orthogonal basis. Used to get orthogonal Distinguishability modes.  <br /></td></tr>
<tr class="separator:abfe8474455fc717080b8f49f40fb4e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfe4f5d26b6e271b9b547c06eb50002" id="r_a7cfe4f5d26b6e271b9b547c06eb50002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cfe4f5d26b6e271b9b547c06eb50002">addPhoton</a> (const WF &amp;, Int, Int)</td></tr>
<tr class="memdesc:a7cfe4f5d26b6e271b9b547c06eb50002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds num new photon to the state with the wave function wf in the Spatial&amp;Polarization mode m.  <br /></td></tr>
<tr class="separator:a7cfe4f5d26b6e271b9b547c06eb50002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cb5151d6af78ae8dfeefc0ed940e93" id="r_a68cb5151d6af78ae8dfeefc0ed940e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68cb5151d6af78ae8dfeefc0ed940e93">apply</a> (const std::vector&lt; Val &gt; &amp;U, const std::vector&lt; Int &gt; &amp;modes)</td></tr>
<tr class="memdesc:a68cb5151d6af78ae8dfeefc0ed940e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a unitary U in second-quantization on the Spatial&amp;Polarization modes in modes (max 2).  <br /></td></tr>
<tr class="separator:a68cb5151d6af78ae8dfeefc0ed940e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf24d1213f07e02cdc788a1ef97d01e6" id="r_aaf24d1213f07e02cdc788a1ef97d01e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf24d1213f07e02cdc788a1ef97d01e6">apply</a> (const Val &amp;U, const Int &amp;mode)</td></tr>
<tr class="memdesc:aaf24d1213f07e02cdc788a1ef97d01e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a unitary U in second-quantization on the Spatial&amp;Polarization modes in modes (max 1).  <br /></td></tr>
<tr class="separator:aaf24d1213f07e02cdc788a1ef97d01e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4606ba0af0c16b37896c1e38a5c903e9" id="r_a4606ba0af0c16b37896c1e38a5c903e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4606ba0af0c16b37896c1e38a5c903e9">swap</a> (Int a, Int b)</td></tr>
<tr class="memdesc:a4606ba0af0c16b37896c1e38a5c903e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two Spatial&amp;Polarization modes, used to implement a PBS.  <br /></td></tr>
<tr class="separator:a4606ba0af0c16b37896c1e38a5c903e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cbb3c0237003362704d8796f1e0b5a" id="r_af7cbb3c0237003362704d8796f1e0b5a"><td class="memItemLeft" align="right" valign="top"><a id="af7cbb3c0237003362704d8796f1e0b5a" name="af7cbb3c0237003362704d8796f1e0b5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clean</b> ()</td></tr>
<tr class="memdesc:af7cbb3c0237003362704d8796f1e0b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all Key-Val pairs where the abs of the amplitude is lower than tol. <br /></td></tr>
<tr class="separator:af7cbb3c0237003362704d8796f1e0b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fe500cc25f551056659db51e430308" id="r_a42fe500cc25f551056659db51e430308"><td class="memItemLeft" align="right" valign="top"><a id="a42fe500cc25f551056659db51e430308" name="a42fe500cc25f551056659db51e430308"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalise</b> ()</td></tr>
<tr class="memdesc:a42fe500cc25f551056659db51e430308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the state. <br /></td></tr>
<tr class="separator:a42fe500cc25f551056659db51e430308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8758dc301dd027de5f53259ada57d0e7" id="r_a8758dc301dd027de5f53259ada57d0e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8758dc301dd027de5f53259ada57d0e7">mul</a> (Val)</td></tr>
<tr class="memdesc:a8758dc301dd027de5f53259ada57d0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the state with a scalar n.  <br /></td></tr>
<tr class="separator:a8758dc301dd027de5f53259ada57d0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24bc5b7dab34953114acb15dc5cdcf2" id="r_aa24bc5b7dab34953114acb15dc5cdcf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa24bc5b7dab34953114acb15dc5cdcf2">overlapWithFilter</a> (const boost::container::flat_map&lt; Int, Int &gt; &amp;, const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;, const std::vector&lt; boost::container::flat_map&lt; Int, Int &gt; &gt; &amp;)</td></tr>
<tr class="memdesc:aa24bc5b7dab34953114acb15dc5cdcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the overlap to a measurement pattern and filters according to a fidelity reference.  <br /></td></tr>
<tr class="separator:aa24bc5b7dab34953114acb15dc5cdcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefea87b93ae1e9095a6d3726ab92f1d" id="r_afefea87b93ae1e9095a6d3726ab92f1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afefea87b93ae1e9095a6d3726ab92f1d">overlapCompl</a> (const std::vector&lt; boost::container::flat_map&lt; Int, Int &gt; &gt; &amp;, const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;={})</td></tr>
<tr class="memdesc:afefea87b93ae1e9095a6d3726ab92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps the part of the state that is either rejected because of the measurement result or because of post-selection.  <br /></td></tr>
<tr class="separator:afefea87b93ae1e9095a6d3726ab92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fe660636cea353109871a94946f17a" id="r_a48fe660636cea353109871a94946f17a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48fe660636cea353109871a94946f17a">loss</a> (const std::vector&lt; Int &gt; &amp;)</td></tr>
<tr class="memdesc:a48fe660636cea353109871a94946f17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performes loss of one photons on the modes in modes.  <br /></td></tr>
<tr class="separator:a48fe660636cea353109871a94946f17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c3fa38a1dcd8c181b2bd53d1bc1178" id="r_ac0c3fa38a1dcd8c181b2bd53d1bc1178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0c3fa38a1dcd8c181b2bd53d1bc1178">collapse</a> (const <a class="el" href="class_key.html">Key</a> &amp;)</td></tr>
<tr class="memdesc:ac0c3fa38a1dcd8c181b2bd53d1bc1178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the current distinguishability conf to a different one - Only use for mapping to less distinguishable conf.  <br /></td></tr>
<tr class="separator:ac0c3fa38a1dcd8c181b2bd53d1bc1178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c84c3722f10ac618c471dc0a9299e7" id="r_af6c84c3722f10ac618c471dc0a9299e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c84c3722f10ac618c471dc0a9299e7">notEmpty</a> (const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;)</td></tr>
<tr class="memdesc:af6c84c3722f10ac618c471dc0a9299e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters out these key that haven't at least one photon in on of the modes in allModes.  <br /></td></tr>
<tr class="separator:af6c84c3722f10ac618c471dc0a9299e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990ce45f9008d91f2854b0c96e42c65c" id="r_a990ce45f9008d91f2854b0c96e42c65c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a990ce45f9008d91f2854b0c96e42c65c">sameDModeDel</a> (const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;, const std::vector&lt; Val &gt; &amp;)</td></tr>
<tr class="memdesc:a990ce45f9008d91f2854b0c96e42c65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps the keys where all Distinguishability Modes are the same for one of the collection of modes in modes.  <br /></td></tr>
<tr class="separator:a990ce45f9008d91f2854b0c96e42c65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class <a class="el" href="class_key.html">Key</a>, class Val, class Real&gt;<br />
class State&lt; Key, Val, Real &gt;</div><p>Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;Key, Val&gt;. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a></td><td><a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> type used in the <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> </td></tr>
    <tr><td class="paramname">Val</td><td>Amplitude type used in the <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a>, e.g. float or std::complex&lt;float&gt; </td></tr>
    <tr><td class="paramname">Real</td><td>Real number type that should be used, e.g. float. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a01fcd8cfa1516d9682b8e99b98b0acff" name="a01fcd8cfa1516d9682b8e99b98b0acff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fcd8cfa1516d9682b8e99b98b0acff">&#9670;&#160;</a></span>State()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;<a class="el" href="class_state.html">::State</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_key.html">Key</a></td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> object from a single key with amplitude 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td><a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> for the <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> (k:1.0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab8877a9c19ffcff50d0354cc10462ba1" name="ab8877a9c19ffcff50d0354cc10462ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8877a9c19ffcff50d0354cc10462ba1">&#9670;&#160;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Par &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an state-like object to a <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a>. If a <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> is already in the state the amplitudes are added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>State-like object to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a4d7c18169dd2bdfa3c73f0b01323bb" name="a3a4d7c18169dd2bdfa3c73f0b01323bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4d7c18169dd2bdfa3c73f0b01323bb">&#9670;&#160;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Par &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Val &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an scaled state-like object to a <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a>. If a <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> is already in the state the amplitudes are added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>State-like object to be added. </td></tr>
    <tr><td class="paramname">v</td><td>p is firsted scaled with v before added to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a985c54028c867aabc1ddd66637991a22" name="a985c54028c867aabc1ddd66637991a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985c54028c867aabc1ddd66637991a22">&#9670;&#160;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::add </td>
          <td>(</td>
          <td class="paramtype">Par &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an state-like object to a <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a>. If a <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> is already in the state the amplitudes are added. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>State-like object to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfe8474455fc717080b8f49f40fb4e02" name="abfe8474455fc717080b8f49f40fb4e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe8474455fc717080b8f49f40fb4e02">&#9670;&#160;</a></span>addBasisElem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Val &gt; <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::addBasisElem </td>
          <td>(</td>
          <td class="paramtype">const WF &amp;</td>          <td class="paramname"><span class="paramname"><em>wf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses Gram-Schmidt procedure to add a basis element to the orthogonal basis. Used to get orthogonal Distinguishability modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wf</td><td>Wave-function of the new entry represented as vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Val&gt; Returns the inner products of wf with all basis elements after G.-S. procedure. </dd></dl>

</div>
</div>
<a id="a7cfe4f5d26b6e271b9b547c06eb50002" name="a7cfe4f5d26b6e271b9b547c06eb50002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cfe4f5d26b6e271b9b547c06eb50002">&#9670;&#160;</a></span>addPhoton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::addPhoton </td>
          <td>(</td>
          <td class="paramtype">const WF &amp;</td>          <td class="paramname"><span class="paramname"><em>wf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds num new photon to the state with the wave function wf in the Spatial&amp;Polarization mode m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wf</td><td>Wave function of the new photons represented as vector </td></tr>
    <tr><td class="paramname">mode</td><td>Spatial&amp;Polarization mode of the new photons </td></tr>
    <tr><td class="paramname">num</td><td>Number of new photons </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68cb5151d6af78ae8dfeefc0ed940e93" name="a68cb5151d6af78ae8dfeefc0ed940e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cb5151d6af78ae8dfeefc0ed940e93">&#9670;&#160;</a></span>apply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Val &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>U</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>modes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a unitary U in second-quantization on the Spatial&amp;Polarization modes in modes (max 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Unitary represented as line </td></tr>
    <tr><td class="paramname">modes</td><td>modes affected by the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf24d1213f07e02cdc788a1ef97d01e6" name="aaf24d1213f07e02cdc788a1ef97d01e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf24d1213f07e02cdc788a1ef97d01e6">&#9670;&#160;</a></span>apply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Val &amp;</td>          <td class="paramname"><span class="paramname"><em>U</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a unitary U in second-quantization on the Spatial&amp;Polarization modes in modes (max 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Unitary, i.e. here a number with abs value 1 </td></tr>
    <tr><td class="paramname">mode</td><td>mode affected by the operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0c3fa38a1dcd8c181b2bd53d1bc1178" name="ac0c3fa38a1dcd8c181b2bd53d1bc1178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c3fa38a1dcd8c181b2bd53d1bc1178">&#9670;&#160;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::collapse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_key.html">Key</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>K</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the current distinguishability conf to a different one - Only use for mapping to less distinguishable conf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td><a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> that encodes the target distinguishability configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa321f0283f93309ab7eb1033edbaefba" name="aa321f0283f93309ab7eb1033edbaefba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa321f0283f93309ab7eb1033edbaefba">&#9670;&#160;</a></span>get_parMoved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Par &amp;&amp; <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::get_parMoved </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Par, i.e. boost::container::flat_map&lt;Key, Val&gt;, object moved. </p>
<dl class="section return"><dt>Returns</dt><dd>Par&amp;&amp; </dd></dl>

</div>
</div>
<a id="a21f03e6d6166f4c24326de519b8d302f" name="a21f03e6d6166f4c24326de519b8d302f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f03e6d6166f4c24326de519b8d302f">&#9670;&#160;</a></span>getPar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Par <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::getPar </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Par, i.e. boost::container::flat_map&lt;Key, Val&gt;, object. </p>
<dl class="section return"><dt>Returns</dt><dd>Par </dd></dl>

</div>
</div>
<a id="a48fe660636cea353109871a94946f17a" name="a48fe660636cea353109871a94946f17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fe660636cea353109871a94946f17a">&#9670;&#160;</a></span>loss()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::loss </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>modes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performes loss of one photons on the modes in modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modes</td><td>Spatial&amp;Polarization modes to perform loss on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8758dc301dd027de5f53259ada57d0e7" name="a8758dc301dd027de5f53259ada57d0e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8758dc301dd027de5f53259ada57d0e7">&#9670;&#160;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::mul </td>
          <td>(</td>
          <td class="paramtype">Val</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the state with a scalar n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Scalar to multiply the state with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab631f04d9ef0521c2058732fb93975d1" name="ab631f04d9ef0521c2058732fb93975d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab631f04d9ef0521c2058732fb93975d1">&#9670;&#160;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::norm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the norm of a state. </p>
<dl class="section return"><dt>Returns</dt><dd>Real The norm of the state </dd></dl>

</div>
</div>
<a id="af6c84c3722f10ac618c471dc0a9299e7" name="af6c84c3722f10ac618c471dc0a9299e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c84c3722f10ac618c471dc0a9299e7">&#9670;&#160;</a></span>notEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::notEmpty </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>allModes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Filters out these key that haven't at least one photon in on of the modes in allModes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allModes</td><td>Spatial&amp;Distinguishability modes to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afefea87b93ae1e9095a6d3726ab92f1d" name="afefea87b93ae1e9095a6d3726ab92f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afefea87b93ae1e9095a6d3726ab92f1d">&#9670;&#160;</a></span>overlapCompl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::overlapCompl </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; boost::container::flat_map&lt; Int, Int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>MVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>allModes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps the part of the state that is either rejected because of the measurement result or because of post-selection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MVec</td><td>Measurement pattern {S&amp;P mode: total occupation-numer}. Filters out the Keys that overlap with one of these. </td></tr>
    <tr><td class="paramname">allModes</td><td>Modes for post-selection. Filters our those that are accepted by post-selection, i.e. for all of the vectors at least one is not occupied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa24bc5b7dab34953114acb15dc5cdcf2" name="aa24bc5b7dab34953114acb15dc5cdcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24bc5b7dab34953114acb15dc5cdcf2">&#9670;&#160;</a></span>overlapWithFilter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt; <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::overlapWithFilter </td>
          <td>(</td>
          <td class="paramtype">const boost::container::flat_map&lt; Int, Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ref</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>allModes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; boost::container::flat_map&lt; Int, Int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>fref</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the overlap to a measurement pattern and filters according to a fidelity reference. </p>
<p>Filters the state such that the measurement patter is overlapping and the fidelity reference is overlapping. Returns the part of the state that is accepted by the measurement and post-selection but is not overlapping with the fidelity refence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The measurement pattern {S&amp;P mode: total occupation-numer}. All S&amp;P modes not in ref are accepted either way. </td></tr>
    <tr><td class="paramname">allModes</td><td>vector of vector of S&amp;P modes of fidelity reference used to pre-filter. At least for one of them all modes have to be occupied. This implements post-selections. </td></tr>
    <tr><td class="paramname">fref</td><td>The fidelity reference. Used to further filter the measurement result, keeps that parts that could contribute to the fidelity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>State&lt;Key, Val, Real&gt; </dd></dl>

</div>
</div>
<a id="a990ce45f9008d91f2854b0c96e42c65c" name="a990ce45f9008d91f2854b0c96e42c65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990ce45f9008d91f2854b0c96e42c65c">&#9670;&#160;</a></span>sameDModeDel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::sameDModeDel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Int &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>modes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Val &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>facs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps the keys where all Distinguishability Modes are the same for one of the collection of modes in modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modes</td><td>For one of the vectors in modes, all Distinguishability Modes have to be the same for the key to be included in the output. </td></tr>
    <tr><td class="paramname">facs</td><td>Factors associated to the vectors in modes. These are used for the amplitudes correspoding to the keys, in which all the modes in the correspoding vector have the same Distinguishability Modes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc5234310447732ffc214861d28fbefa" name="abc5234310447732ffc214861d28fbefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5234310447732ffc214861d28fbefa">&#9670;&#160;</a></span>set() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_key.html">Key</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Val &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts/assigns a new <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> Value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td><a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> for new entry. If k is already in the <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> the amplitude is overwritten with v. </td></tr>
    <tr><td class="paramname">v</td><td>new amplitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f2188cc37ec161676437fa8a74e4d4e" name="a2f2188cc37ec161676437fa8a74e4d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2188cc37ec161676437fa8a74e4d4e">&#9670;&#160;</a></span>set() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const Par &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the actual <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> data to p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The data is set to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa805363c158f4c2b87764573b6456c31" name="aa805363c158f4c2b87764573b6456c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa805363c158f4c2b87764573b6456c31">&#9670;&#160;</a></span>set() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Val &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts/assigns a new <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> Value pair. The key is implicitly given by (a,b,c). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Spatial&amp;Polarization mode </td></tr>
    <tr><td class="paramname">b</td><td>Distinguishability mode </td></tr>
    <tr><td class="paramname">c</td><td>Occupation number. </td></tr>
    <tr><td class="paramname">v</td><td>new amplitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa72801b6de32a55c5c53d379e1d6937c" name="aa72801b6de32a55c5c53d379e1d6937c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72801b6de32a55c5c53d379e1d6937c">&#9670;&#160;</a></span>set() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the lossMode to n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Int the lossMode is set to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16d6ccad44894abc4330c4fbe9270d5f" name="a16d6ccad44894abc4330c4fbe9270d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d6ccad44894abc4330c4fbe9270d5f">&#9670;&#160;</a></span>set() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_key.html">Key</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Val &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts/assigns a new <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> Value pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td><a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> for new entry. If k is already in the <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> the amplitude is overwritten with v. <a class="el" href="class_key.html" title="Key class, that implements the functions needed for State. Inherits from boost::container::flat_map&lt;s...">Key</a> is moved. </td></tr>
    <tr><td class="paramname">v</td><td>new amplitude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22d3c086d22cb5792ba4098877199190" name="a22d3c086d22cb5792ba4098877199190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d3c086d22cb5792ba4098877199190">&#9670;&#160;</a></span>set() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Par &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the actual <a class="el" href="class_state.html" title="Definition of the data structure used to represent states. Inherits from boost::container::flat_map&lt;K...">State</a> data to p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The data is set to. Moved input. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a522ab1b3df807b91edf4e67dda23f604" name="a522ab1b3df807b91edf4e67dda23f604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522ab1b3df807b91edf4e67dda23f604">&#9670;&#160;</a></span>set() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Real</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the tolerance to t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Real the tolerance is set to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed9eb3b634fa0ade70650bf58795ed92" name="aed9eb3b634fa0ade70650bf58795ed92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9eb3b634fa0ade70650bf58795ed92">&#9670;&#160;</a></span>set() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Val(*</td>          <td class="paramname"><span class="paramname"><em>f&#160;</em></span>)(const WF &amp;, const WF &amp;)</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the overlap function to f. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>function that gets two vector&lt;Val&gt; and returns a Val, that is the overlap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4606ba0af0c16b37896c1e38a5c903e9" name="a4606ba0af0c16b37896c1e38a5c903e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4606ba0af0c16b37896c1e38a5c903e9">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="class_key.html">Key</a> , class Val , class Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_state.html">State</a>&lt; <a class="el" href="class_key.html">Key</a>, Val, Real &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two Spatial&amp;Polarization modes, used to implement a PBS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First Spatial&amp;Polarization mode </td></tr>
    <tr><td class="paramname">b</td><td>Second Spatial&amp;Polarization mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/fabianwiesner/Desktop/Work/PhotonicQC/FidCodeUpdate/simphoqcirc/<a class="el" href="_state_8hpp.html">State.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
